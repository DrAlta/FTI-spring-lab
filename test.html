<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.2.2/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>AM Concepting Mapping Toy</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
      }
      #buttons {
        position: absolute;
        top: 5px;
        left: 10px;
      }
    #menu {
        display: none;
        position: absolute;
        width: 60px;
        background-color: white;
        box-shadow: 0 0 5px grey;
        border-radius: 3px;
    }
    </style>
    </style>
  </head>

  <body>
    <div id="container"></div>
    <div id="buttons">
      <button id="addNode">
        Add Node
      </button>
    <div id="menu">
      <div><button id="pulse-button">Pulse</button><button id="delete-button">Delete</button></div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/gun/lib/not.js"></script>

    <script>
	//start gun stuff
	var workspace = Gun().get('workspace'); 
	var nodes = workspace.get('nodes');
	nodes.not(function (key) {console.log("not "+key)})
      var width = window.innerWidth;
      var height = window.innerHeight;

      var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
      });

      var textLayer = new Konva.Layer();
      stage.add(textLayer);

	var tr = new Konva.Transformer({
		//node: nodeX,
		rotateEnabled: false,
		enabledAnchors: ['middle-left', 'middle-right'],
		// set minimum width of text
		boundBoxFunc: function(oldBox, newBox) {
			newBox.width = Math.max(30, newBox.width);
			return newBox;
		}
	});


    var makeNode = function (title, posx, posy, id) {
        var textNode = new Konva.Text({
            text: title,
            x: posx,
            y: posy,
			align: 'center',
            fontSize: 20,
            draggable: true,
            width: 200,
			id: id
        });
		textLayer.add(textNode);
        textNode.on('dblclick', () => {
            // hide text node and transformer:
            textNode.hide();
            tr.hide();
            textLayer.draw();

            // create textarea over canvas with absolute position
            // first we need to find position for textarea
            // how to find it?

            // at first lets find position of text node relative to the stage:
            var textPosition = textNode.absolutePosition();

            // then lets find position of stage container on the page:
            var stageBox = stage.container().getBoundingClientRect();

            // so position of textarea will be the sum of positions above:
            var areaPosition = {
                x: stageBox.left + textPosition.x,
                y: stageBox.top + textPosition.y
            };

            // create textarea and style it
            var textarea = document.createElement('textarea');
            document.body.appendChild(textarea);

            // apply many styles to match text on canvas as close as possible
            // remember that text rendering on canvas and on the textarea can be different
            // and sometimes it is hard to make it 100% the same. But we will try...
            textarea.value = textNode.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
            textarea.style.height =
                textNode.height() - textNode.padding() * 2 + 5 + 'px';
            textarea.style.fontSize = textNode.fontSize() + 'px';
            //textarea.style.border = 'none';
            textarea.style.padding = '0px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            //textarea.style.background = 'none';
            //textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = textNode.lineHeight();
            textarea.style.fontFamily = textNode.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = textNode.align();
            textarea.style.color = textNode.fill();
            //rotation = textNode.rotation();
            var transform = '';
//            if (rotation) {
  //              transform += 'rotateZ(' + rotation + 'deg)';
    //        }

            var px = 0;
            // also we need to slightly move textarea on firefox
            // because it jumps a bit
            var isFirefox =
                navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isFirefox) {
                px += 2 + Math.round(textNode.fontSize() / 20);
            }
            transform += 'translateY(-' + px + 'px)';

            textarea.style.transform = transform;

            // reset height
            textarea.style.height = 'auto';
            // after browsers resized it we can set actual value
            textarea.style.height = textarea.scrollHeight + 3 + 'px';

            textarea.focus();

            function removeTextarea() {
                textarea.parentNode.removeChild(textarea);
                window.removeEventListener('click', handleOutsideClick);
                textNode.show();
                tr.show();
                tr.forceUpdate();
                textLayer.draw();
            }

            function setTextareaWidth(newWidth) {
                if (!newWidth) {
                // set width for placeholder
                newWidth = textNode.placeholder.length * textNode.fontSize();
                }
                // some extra fixes on different browsers
                var isSafari = /^((?!chrome|android).)*safari/i.test(
                    navigator.userAgent
                );
                var isFirefox =
                    navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                if (isSafari || isFirefox) {
                    newWidth = Math.ceil(newWidth);
                }

                var isEdge =
                    document.documentMode || /Edge/.test(navigator.userAgent);
                if (isEdge) {
                    newWidth += 1;
                }
                textarea.style.width = newWidth + 'px';
            }

            textarea.addEventListener('keydown', function(e) {
                // hide on enter
                // but don't hide on shift + enter
                if (e.keyCode === 13 && !e.shiftKey) {
                    //textNode.text(textarea.value);
					console.log('putting:'+textNode.id());
					nodes.get(textNode.id()).put({title: textarea.value});
                    removeTextarea();
                }
                // on esc do not set value back to node
                if (e.keyCode === 27) {
                    removeTextarea();
                }
            });

            textarea.addEventListener('keydown', function(e) {
                scale = textNode.getAbsoluteScale().x;
                setTextareaWidth(textNode.width() * scale);
                textarea.style.height = 'auto';
                textarea.style.height =
                textarea.scrollHeight + textNode.fontSize() + 'px';
            });

            function handleOutsideClick(e) {
                if (e.target !== textarea) {
				console.log('putting:'+textNode.id());
					nodes.get(textNode.id()).put({title: textarea.value});

//                    textNode.text(textarea.value);
                    removeTextarea();
                }
            }
            setTimeout(() => {
                window.addEventListener('click', handleOutsideClick);
            });
        });
    };

  //      textLayer.add(textNode2);


    textLayer.add(tr);
    var focusTran = function (nodeX) {
	    tr.node(nodeX);
		tr.show();
        nodeX.on('transform', function() {
            // reset scale, so only with is changing by transformer
            nodeX.setAttrs({
            width: nodeX.width() * nodeX.scaleX(),
            scaleX: 1
            });
        });

	    textLayer.draw();
    };
	textLayer.on('click', function(evt) {
        focusTran(evt.target);
	});

	var  appState = 'idle';
	document.getElementById('addNode').addEventListener(
        'click',
        function() {
            appState = 'create';
        },
        false
    );
	
    stage.on('click', function(e) {
        if (appState == 'create'){
            var pos = stage.getPointerPosition();
	        nodes.set({x: pos.x, y: pos.y, title: "New Node"});
			appState = 'idle';
		};
	});
	
	textLayer.on('dragend', function(evt) {
	    var trgt= evt.target;
        console.log('dragend'+ trgt.id());
		nodes.get(trgt.id()).put({x: trgt.x(), y: trgt.y()});
    });
	
    nodes.map().on(function(nodeX, id){
            console.log(id);
			var oldnode = stage.findOne('#' + id);
			if (nodeX) {
			    if(oldnode){
	     		    oldnode.text(nodeX.title);
			       // oldnode.x(nodeX.x);
			       //oldnode.y(nodeX.y);
				} else {
				 	makeNode(nodeX.title, nodeX.x, nodeX.y, '' + id)
				 };
			} else {
			    if(oldnode){
				    oldnode.destroy();
				};
			};
	        textLayer.draw();
    });

//////////////////////////////////////////////////////////////////////////
    // setup menu
    let currentShape;
    var menuNode = document.getElementById('menu');
    document.getElementById('pulse-button').addEventListener('click', () => {
        currentShape.to({
            scaleX: 2,
            scaleY: 2,
            onFinish: () => {
                currentShape.to({ scaleX: 1, scaleY: 1})
            }
        })
    });

    document.getElementById('delete-button').addEventListener('click', () => {
	    if(currentShape){
		console.log('deleting ' + currentShape.id())
		nodes.get(currentShape.id()).put(null);
        currentShape.destroy();
		tr.hide();
        textLayer.draw();
		};
    });

      window.addEventListener('click', () => {
        // hide menu 
          menuNode.style.display = 'none';
      })


      stage.on('contextmenu', function(e) {
        // prevent default behavior
		console.log("contest");
        e.evt.preventDefault();
        if (e.target === stage) {
          // if we are on empty place of the stage we will do nothing
          return;
        }
        currentShape = e.target;
        // show menu
        menuNode.style.display = 'initial';
        var containerRect = stage.container().getBoundingClientRect();
        menuNode.style.top = containerRect.top + stage.getPointerPosition().y + 4 +'px';
        menuNode.style.left = containerRect.left + stage.getPointerPosition().x + 4 + 'px';
      });
//////////////////////////////////////////////////////////////////////////


	  textLayer.draw();
    </script>
  </body>
</html>