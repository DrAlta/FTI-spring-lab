<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@4.2.2/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>AM Concepting Mapping Toy</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
        }
        mapcontainer {
        }
        #buttons {
            position: absolute;
            top: 5px;
            left: 10px;
        }
        #menu {
            display: none;
            position: absolute;
            width: 60px;
            background-color: white;
            box-shadow: 0 0 5px grey;
            border-radius: 3px;
        }
    </style>
    </style>
  </head>

  <body>
    <div style="display: flex">
        <div id="mapcontainer"></div>
        <div id="contenty">te =======================================================================st</div>
    </div>
    <div id="buttons">
      <button id="addNode">
        Add Node
      </button>
      <button id="addLink" style="display: none">
        Add Link
      </button>
    <div id="menu">
      <div><button id="menuAddLink" style="display: none">Add Link</button><button id="delete-button">Delete</button></div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/not.js"></script>

    <script>
    var gunWorkspace = Gun().get('workspace'); 
    var gunNodes = gunWorkspace.get('nodes');
    var gunLinks = gunWorkspace.get('links');

    var appLinks = new Set();
    var linksByNode = {};
    
    var width = window.innerWidth;
    var height = window.innerHeight;

    var stage = new Konva.Stage({
        container: 'mapcontainer',
        width: width*2/3,
        height: height
      });

    var linkLayer = new Konva.Layer();
    stage.add(linkLayer);

    var textLayer = new Konva.Layer();
    stage.add(textLayer);

    var tr = new Konva.Transformer({
        //node: nodeX,
        rotateEnabled: false,
        enabledAnchors: ['middle-left', 'middle-right'],
        // set minimum width of text
        boundBoxFunc: function(oldBox, newBox) {
            newBox.width = Math.max(30, newBox.width);
            return newBox;
        }
    });
//////////////////////////////////////////////
//link stuff
function updateLink (linkX){
    var source = appLinks[linkX].source;
    var target = appLinks[linkX].target;

    // test for source node
    if(!(sourceNode = textLayer.findOne('#' + source))) {
	    console.log("source:" + source +" is missing"); 
	};
    // test for target node
    if(!(targetNode = textLayer.findOne('#' + target))) {
	    console.log("target:" + target +" is missing"); 
	};

////////////
	if(sourceNode && targetNode) {
	    console.log("linking " + source + " to " + target + " with " + linkX);
        var oldLink = linkLayer.findOne('#' + linkX);
        if (oldLink) {
            console.log('found link:' + linkX);
            oldLink.points([sourceNode.x(), sourceNode.y(), targetNode.x(), targetNode.y()]);
        } else {

            var arrow = new Konva.Arrow({
                x: 0,
                y: 0,
                points: [sourceNode.x(), sourceNode.y(), targetNode.x(), targetNode.y()],
                pointerLength: 20,
                pointerWidth: 20,
                fill: 'black',
                stroke: 'black',
                strokeWidth: 4
            });
            linkLayer.add(arrow);
	    };
        linkLayer.draw();
    };
};
function addLink (id, source, target) {
    //add link to appLinks
    appLinks[id] = {source: source, target: target}
	//add source to LinksByNode	
	if (linksByNode.hasOwnProperty(source)){
		console.log("Adding " + id + " to " + source)
	    linksByNode[source].add(id)
	} else {
		console.log("creating linksByNode:" + source + " (s) with " + id)
		linksByNode[source] = new Set(id)
	
	}
	//add target to LinksByNode
	if (linksByNode.hasOwnProperty(target)){
		console.log("Adding " + id + " to " + target)
	    linksByNode[target].add(id)
	} else {
		console.log("creating linksByNode:" + target + " (t) with " + id)
		linksByNode[target] = new Set(id)
	
	}
    updateLink(id);
}
/////////////////////////////////////////////

    var makeNode = function (title, posx, posy, id) {
        var textNode = new Konva.Text({
            text: title,
            x: posx,
            y: posy,
            align: 'center',
            fontSize: 20,
            draggable: true,
            width: 200,
            id: id
        });
        textLayer.add(textNode);
        textNode.on('dblclick', () => {
            // hide text node and transformer:
            textNode.hide();
            tr.hide();
            //node still there so don't clear selection
            textLayer.draw();

            // create textarea over canvas with absolute position
            // first we need to find position for textarea
            // how to find it?

            // at first lets find position of text node relative to the stage:
            var textPosition = textNode.absolutePosition();

            // then lets find position of stage container on the page:
            var stageBox = stage.container().getBoundingClientRect();

            // so position of textarea will be the sum of positions above:
            var areaPosition = {
                x: stageBox.left + textPosition.x,
                y: stageBox.top + textPosition.y
            };

            // create textarea and style it
            var textarea = document.createElement('textarea');
            document.body.appendChild(textarea);

            // apply many styles to match text on canvas as close as possible
            // remember that text rendering on canvas and on the textarea can be different
            // and sometimes it is hard to make it 100% the same. But we will try...
            textarea.value = textNode.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
            textarea.style.height =
                textNode.height() - textNode.padding() * 2 + 5 + 'px';
            textarea.style.fontSize = textNode.fontSize() + 'px';
            //textarea.style.border = 'none';
            textarea.style.padding = '0px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            //textarea.style.background = 'none';
            //textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = textNode.lineHeight();
            textarea.style.fontFamily = textNode.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = textNode.align();
            textarea.style.color = textNode.fill();
            //rotation = textNode.rotation();
            var transform = '';
//            if (rotation) {
  //              transform += 'rotateZ(' + rotation + 'deg)';
    //        }

            var px = 0;
            // also we need to slightly move textarea on firefox
            // because it jumps a bit
            var isFirefox =
                navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isFirefox) {
                px += 2 + Math.round(textNode.fontSize() / 20);
            }
            transform += 'translateY(-' + px + 'px)';

            textarea.style.transform = transform;

            // reset height
            textarea.style.height = 'auto';
            // after browsers resized it we can set actual value
            textarea.style.height = textarea.scrollHeight + 3 + 'px';

            textarea.focus();

            function removeTextarea() {
                textarea.parentNode.removeChild(textarea);
                window.removeEventListener('click', handleOutsideClick);
                textNode.show();
                tr.show();
                tr.forceUpdate();
                textLayer.draw();
            }

            function setTextareaWidth(newWidth) {
                if (!newWidth) {
                // set width for placeholder
                newWidth = textNode.placeholder.length * textNode.fontSize();
                }
                // some extra fixes on different browsers
                var isSafari = /^((?!chrome|android).)*safari/i.test(
                    navigator.userAgent
                );
                var isFirefox =
                    navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
                if (isSafari || isFirefox) {
                    newWidth = Math.ceil(newWidth);
                }

                var isEdge =
                    document.documentMode || /Edge/.test(navigator.userAgent);
                if (isEdge) {
                    newWidth += 1;
                }
                textarea.style.width = newWidth + 'px';
            }

            textarea.addEventListener('keydown', function(e) {
                // hide on enter
                // but don't hide on shift + enter
                if (e.keyCode === 13 && !e.shiftKey) {
                    //textNode.text(textarea.value);
                    console.log('putting:'+textNode.id());
                    gunNodes.get(textNode.id()).put({title: textarea.value});
                    removeTextarea();
                }
                // on esc do not set value back to node
                if (e.keyCode === 27) {
                    removeTextarea();
                }
            });

            textarea.addEventListener('keydown', function(e) {
                scale = textNode.getAbsoluteScale().x;
                setTextareaWidth(textNode.width() * scale);
                textarea.style.height = 'auto';
                textarea.style.height =
                textarea.scrollHeight + textNode.fontSize() + 'px';
            });

            function handleOutsideClick(e) {
                if (e.target !== textarea) {
                console.log('putting:'+textNode.id());
                    gunNodes.get(textNode.id()).put({title: textarea.value});

//                    textNode.text(textarea.value);
                    removeTextarea();
                }
            }
            setTimeout(() => {
                window.addEventListener('click', handleOutsideClick);
            });
        });
    };

  //      textLayer.add(textNode2);


    textLayer.add(tr);
    var focusTran = function (nodeX) {
        tr.node(nodeX);
        tr.show();
        nodeX.on('transform', function() {
            // reset scale, so only with is changing by transformer
            nodeX.setAttrs({
            width: nodeX.width() * nodeX.scaleX(),
            scaleX: 1
            });
        });
        setSelection(nodeX.id())  
        textLayer.draw();
    };
    textLayer.on('click', function(evt) {
        if(appState == 'idle') {
        focusTran(evt.target);
        } else if (appState == 'link'){
            console.log("making link from " + selectedNode + " to "+ evt.target.id());
            gunLinks.set({source: selectedNode, target: evt.target.id()})
        };
    });

    var  appState = 'idle';
    var oldSelectedNode = null;
    var selectedNode = null;
    
    function clearSelection() {
        selectedNode = null;
        document.getElementById('addLink').style.display = 'none';
        document.getElementById('menuAddLink').style.display = 'none';

    };
    function setSelection(id) {
        oldSelectedNode = selectedNode;
        selectedNode = id;
        document.getElementById('addLink').style.display = 'initial';
        document.getElementById('menuAddLink').style.display = 'initial';
        
    };

    document.getElementById('addNode').addEventListener(
        'click',
        function() {
            appState = 'create';
        },
        false
    );

    document.getElementById('addLink').addEventListener(
        'click',
        function() {
            appState = 'link';
        },
        false
    );

    
    stage.on('click', function(e) {
        if (appState == 'create'){
            var pos = stage.getPointerPosition();
            gunNodes.set({x: pos.x, y: pos.y, title: "New Node"});
            appState = 'idle';
        };
    });
    
    textLayer.on('dragend', function(evt) {
        var trgt= evt.target;
        console.log('dragend'+ trgt.id());
        gunNodes.get(trgt.id()).put({x: trgt.x(), y: trgt.y()});
    });
    
    gunNodes.map().on(function(nodeX, id){
            console.log(id);
            var oldnode = textLayer.findOne('#' + id);
            if (nodeX) {
                if(oldnode){
                    oldnode.text(nodeX.title);
                   // oldnode.x(nodeX.x);
                   //oldnode.y(nodeX.y);
                } else {
                    makeNode(nodeX.title, nodeX.x, nodeX.y, '' + id)
                 };
            } else {
                if(oldnode){
                    oldnode.destroy();
                };
            };
            textLayer.draw();
    });

    gunLinks.map().on(function(linkX, id){
            console.log("event link" + id);
            addLink(id, linkX.source, linkX.target);
    });

//////////////////////////////////////////////////////////////////////////
    // setup menu
    let currentShape;
    var menuNode = document.getElementById('menu');


    document.getElementById('delete-button').addEventListener('click', () => {
        if(currentShape){
        console.log('deleting ' + currentShape.id())
        gunNodes.get(currentShape.id()).put(null);
        currentShape.destroy();
        tr.hide();
        clearSelection();
        textLayer.draw();
        };
    });

      window.addEventListener('click', () => {
        // hide menu 
          menuNode.style.display = 'none';
      })

      stage.on('contextmenu', function(e) {
        // prevent default behavior
        console.log("contest");
        e.evt.preventDefault();
        if (e.target === stage) {
          // if we are on empty place of the stage we will do nothing
          return;
        }
        currentShape = e.target;
        // show menu
        menuNode.style.display = 'initial';
        var containerRect = stage.container().getBoundingClientRect();
        menuNode.style.top = containerRect.top + stage.getPointerPosition().y + 4 +'px';
        menuNode.style.left = containerRect.left + stage.getPointerPosition().x + 4 + 'px';
      });
//////////////////////////////////////////////////////////////////////////


      textLayer.draw();
    </script>
  </body>
</html>